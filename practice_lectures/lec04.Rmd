---
title: "Lecture 3 MATH 390.4 Queens College"
author: "Professor Adam Kapelner"
date: "February 7, 2018"
---

## Computer Science Sidebar

Before we get back to modeling, it is worth knowing a couple more data structures in R. These are not "data [science] types", these are "[computer science] data types". 

The first are "lists" which are "ordered hashmaps" or "ordered dictionaries" or "hash tables". if You don't know what this is, you should read about this online as it should have been covered in a intro to CS class.

```{r}
dict = list()
dict$a = "first"
dict$b = "second"
dict$c = "third"
dict
length(dict)
names(dict) #keys
dict_unlisted = unlist(dict) #values
dict_unlisted
class(dict_unlisted) #i.e. a vector
#three ways to access values by key / ordered location
dict$a
dict[["a"]]
dict[[1]] #value of first entered key
class(dict[[1]])
dict[[1 : 2]] #bombs
#now let's try to access a value for a non-existent key / ordered location
dict$q
dict[["q"]]
dict[[4]] #bombs
#convenient means to subset the list
dict[1]
class(dict[1])
dict[1 : 2]
dict[1 : 4] #this is the reason this type of access is not recommended
dict = list("first", "second", "third") #no key => value... what happens?
dict #default keys are the numbers 1, 2, ...
dict[[1]]
```

Lists conveniently allow all sorts of data types.

```{r}
varied_dict = list()
varied_dict$a = "first"
varied_dict$b = 2
varied_dict$c = 1 : 7
varied_dict$d = matrix(NA, nrow = 2, ncol = 2)
varied_dict[["the last entry"]] = function(x){x^2} #this key is not recommended
varied_dict
varied_dict$`the last entry` #note the tick marks (sometimes seen) needed due to spaces in key name
length(varied_dict)
names(varied_dict)
```

They have lots of uses in data science applications. We will likely see them in class and if not, you'll definitely see them in the real world. Note that data.frame objects are implemented as lists as well as many other common R objects.


The second is arrays i.e. are multidimensional vectors

```{r}
x = array(1 : 5, 5)
x
X = array(1 : 25, dim = c(5, 5))
X
X = array(1 : 125, dim = c(5, 5, 5))
X
X[1, , ]
X[, 1, ]
X[, , 1]
X = array(1 : 125, dim = c(5, 5, 5))
X
```

These can be associative arrays too and operate like a hash of vectors across arbitrary dimensions:

```{r}
X = array(1 : 125, 
          dim = c(5, 5, 5),
          dimnames = list(
            c("A", "B", "C", "D", "E"),
            c("I", "II", "III", "IV", "V"),
            c("blue", "red", "green", "yellow", "orange")
          ))
X
X["A", , ]
X[, "III", ]
X[, , "orange"]
X["C", , "orange"]
X["C", "IV", "orange"]
```


## Saving and Loading in R

Let's save one object:

```{r}
save(varied_dict, file = "varied_dict.RData") #RData is recommended extension for convenience
rm(varied_dict)
varied_dict
load("varied_dict.RData")
varied_dict
```

Or save the whole workspace:

```{r}
save.image("all_work.RData")
rm(list = ls())
ls() #empty vector i.e. nothing here!
load("all_work.RData")
ls()
```

```{r}
rm(list = ls()) #cleanup everything
```

## Libraries in R

So far we've only made use of "base R". This is the funcionality included from a vanilla installation of R. 

R has a huge worldwide community of contributors. Some contribute to newer version of base R, but most create open-source "R packages" or "libraries". Many libraries come preinstalled. For instance, the MASS library which stands for "Modern Applied Statistics with S" (a famous textbook of R). We can call a function from the MASS library via the following:

```{r}
MASS::as.fractions(0.99)
MASS::as.fractions(pi)
```

Note we cannot just

```{r}
as.fractions(pi)
```

We made use of the scope operator "::" to access a namespace beyond the usual "global namespace" which we've been used to. 

If we are using the MASS library a lot, using the scope operator may get annoying. So similar to the "with" command, we can call

```{r}
library(MASS)
```

which loads all public methods (aka "exported" functions) into the public namespace. Bonus: you can use the ":::" to access the private / internal functions and variables. Java developers would cringe!

Now, after the library invocation we can do the following and treat it as a normal function:

```{r}
as.fractions(pi)
```

The content for the MASS package was sitting on the hard drive since it comes with R. But what if you want to use a package that does not come with R? We'll have to install the package just like pip for Python, Rubygems for Ruby, R has a package management system built in. For example, here's a useful package for time series / finance stuff:

```{r}
install.packages("tseries")
```

Note that it knew where to go online - it went to a CRAN mirror. CRAN is the official repository for R packages.

Might as well load it:

```{r}
library(tseries)
```
This is its welcome message.

This library is really cool e.g.

```{r}
ibm_stock_history = get.hist.quote(instrument = "IBM", start = "2018-01-01", end = "2018-02-01")
ibm_stock_history
```

Is this a data frame?

```{r}
class(ibm_stock_history)
```

Nope - they made their own data type. We will get there if I choose to do the unit on "writing your own R packages".

Let's say you're sharing your code with someone and one of your lines is loading a library e.g.

```{r}
library(doParallel)
```
And my computer doesn't have this library. Then we need to stop what we're doing and install. This could be annoying. Here is a convenience: use the pacman package that installs if necessary:

```{r}
if (!require("pacman")){install.packages("pacman")} #installs pacman if necessary but does not load it!
pacman::p_load(devtools) #ensures that devtools gets installed and loaded into the workspace but pacman does not (very tidy)!
```

It is typical to then have a few lines declaring all packages on top of your R/Rmd script file. Here is an example header from one of my projects:

```{r}
#if (!require("pacman")){install.packages("pacman")}
#pacman::p_load(knitr, randomForest, dplyr, tidyverse, doParallel, xtable, pracma, yaml)
```

I'm going to require this for HW / projects, etc.

The devtools package is important for modern R usage. It allows downloading R packages directly from source that are not even on CRAN. This allows you to get "bleeding edge" features. For example:

```{r}
install_github("yihui/knitr")
```

However this doesn't always work!

```{r}
install_github("hadley/ggplot2")
```

Why did this fail? Because this computer is not setup for compiling C++. This is one of the big advantages of using Linux and MAC over Windows - Windows just is more buggy when it comes to "real coding" and it gets in the way when you're out there trying to get stuff done.

Note, you can use the pacman library for this type of installation too. So your header becomes:

```{r}
if (!require("pacman")){install.packages("pacman")}
pacman::p_load(devtools)
pacman::p_load_gh("hadley/ggplot2")
```

## Errors and Warnings

You can write better functions if you make use of errors and warnings. Java forces you to catch likely errors via the "throws" designation for a method but there is no such requirement in R.

* Errors are unrecoverable, they halt execution i.e. red lights
* Warnings (under usual execution) do not halt execution, but they display a message, i.e. yellow lights

Here's how they work:

```{r}
my_vector_sum = function(xs){
  
  if (!(class(xs) %in% c("numeric", "integer"))){ #short for class(xs) == "numeric" | class(xs) == "integer"
    #stop("You need to pass in a vector of numbers not a vector of type \"", class(xs), "\".\n") #throw error!
    warning("Your vector of type \"", class(xs), "\" will be coerced to numbers.\n") #throw error!
  }
  
  tot = 0
  for (x in as.numeric(as.factor(xs))){
    tot = tot + x
  }
  tot
}
my_vector_sum(c(1, 2, 3))
my_vector_sum(c("a", "b", "c"))
```

There is a try-catch



```{r}
rm(list = ls())
```



## Continue discussion concerning data frames and the modeling from class

We quickly recreate our data frame from last class:

```{r}
n = 100
X = data.frame(
  salary = round(rnorm(n, 50000, 20000)),
  has_past_unpaid_loan = rbinom(n, size = 1, prob = 0.2),
  past_crime_severity = sample(
    c("no crime", "infraction", "misdimeanor", "felony"),
    size = n,
    replace = TRUE,
    prob = c(.50, .40, .08, .02)
  )
)
row.names(X) = c(
  "Sophia", "Emma", "Olivia", "Ava", "Mia", "Isabella", "Riley", 
  "Aria", "Zoe", "Charlotte", "Lily", "Layla", "Amelia", "Emily", 
  "Madelyn", "Aubrey", "Adalyn", "Madison", "Chloe", "Harper", 
  "Abigail", "Aaliyah", "Avery", "Evelyn", "Kaylee", "Ella", "Ellie", 
  "Scarlett", "Arianna", "Hailey", "Nora", "Addison", "Brooklyn", 
  "Hannah", "Mila", "Leah", "Elizabeth", "Sarah", "Eliana", "Mackenzie", 
  "Peyton", "Maria", "Grace", "Adeline", "Elena", "Anna", "Victoria", 
  "Camilla", "Lillian", "Natalie", "Jackson", "Aiden", "Lucas", 
  "Liam", "Noah", "Ethan", "Mason", "Caden", "Oliver", "Elijah", 
  "Grayson", "Jacob", "Michael", "Benjamin", "Carter", "James", 
  "Jayden", "Logan", "Alexander", "Caleb", "Ryan", "Luke", "Daniel", 
  "Jack", "William", "Owen", "Gabriel", "Matthew", "Connor", "Jayce", 
  "Isaac", "Sebastian", "Henry", "Muhammad", "Cameron", "Wyatt", 
  "Dylan", "Nathan", "Nicholas", "Julian", "Eli", "Levi", "Isaiah", 
  "Landon", "David", "Christian", "Andrew", "Brayden", "John", 
  "Lincoln"
)
X
```

Remember our cross tab? Now we can get fancier using our new libary skills. Any Stata fans out there?

```{r}
pacman::p_load(gmodels)
CrossTable(X$has_past_unpaid_loan, X$past_crime_severity, chisq = TRUE)
```


And add a new variable, the response to the data frame:

```{r}
X$paid_back_loan = factor(rbinom(n, size = 1, prob = 0.9), labels = c("No", "Yes"))
```

Note that our matrix is now no longer just $X$; it includes $y$. I could make a renamed copy, but I want to show off dropping this column and create a new object that's both features and response column-binded together:

```{r}
y = X$paid_back_loan
X$paid_back_loan = NULL #drop column
Xy = cbind(X, y) #an aside: what do you think the "rbind" function does?
head(Xy) #make sure that worked
summary(Xy) #much better now!
#Note: Xy = X; rm(X) would've been easier
```

I prefer calling the full training set ${X, y}$ a data frame called $Xy$. 

Most data sets are names some descriptive name like "loandata" or "cars". Here are undoubtedly some of the most famous datasets:

```{r}
data(Boston, package = "MASS") #package argument not needed if package loaded 
head(Boston)
data(iris)
head(iris)
```


The object $X$ is now extraneous, so we should clean up our workspace now.

```{r}
rm(list = setdiff(ls(), "Xy"))
```


## Do some models!

Let's compute the threshold model and see what happens. Here's an inefficent but quite pedagogical way to do this:

```{r}
n = nrow(Xy)
num_errors_by_parameter = matrix(NA, nrow = n, ncol = 2)
colnames(num_errors_by_parameter) = c("threshold_param", "num_errors")
y_logical = Xy$y == "Yes"
for (i in 1 : n){
  threshold = Xy$salary[i]
  num_errors = sum((Xy$salary > threshold) == y_logical)
  num_errors_by_parameter[i, ] = c(threshold, num_errors)
}
num_errors_by_parameter

#now grab the smallest num errors
best_row = order(num_errors_by_parameter[, "num_errors"])[1]
num_errors_by_parameter[best_row, "threshold_param"]
```

Now let's do the perceptron for one dimension - just salary. You will do the other two for homework.

```{r}
MAX_ITER = 1000
w_vec = c(0, 0)
y_binary = as.numeric(Xy$y == "Yes") #convenience

for (iter in 1 : MAX_ITER){  
  for (i in 1 : n){
    x_i = c(1, Xy[i, 1]) #prepend the 1
    yhat_i = ifelse(sum(x_i * w_vec) > 0, 1, 0)
    y_i = y_binary[i]
    w_vec = w_vec + (y_i - yhat_i) * x_i
  }
}
w_vec
```

